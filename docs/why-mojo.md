# 为何是 Mojo🔥

当我们创立 Modular 时，我们本无意构建一种新的编程语言。但是当我们构建 [面向 ML/AI 基础设施的统一平台](https://www.modular.com/blog/the-case-for-a-next-generation-ai-developer-platform) 时，我们意识到整个技术栈的编程过于复杂。同时，我们手写了大量 MLIR，整个过程很费力。

我们需要的是一种创新且可扩展的编程模型，用于面向加速器（accelerators）和 AI 领域普遍存在的若干异构系统。这意味着编程语言需要具有强大的编译时元编程、集成自适应编译技术、缓存整个编译流程以及现有编程语言不支持的其他特性。

尽管加速器很重要，但最普遍且有时被忽视的“加速器”之一是主机 CPU。如今，CPU 拥有许多类似张量核（tensor-core-like）的加速器模块和其他 AI 加速单元，同时，它们也用于专用加速器无法处理的场景（例如：数据加载，预处理/后处理以及与外部系统的集成），因此，我们不能仅用一种仅适配特定处理器的“加速器语言”来提升 AI 性能。

面对 AI 应用场景需要解决所有这些问题，我们认为没有理由不能只用一种语言来完成。因此，Mojo 诞生了。

## 采用下一代编译器技术的语言

当我们意识到现有的编程语言无法解决 AI 计算的挑战时，我们开始重新思考如何设计和实现编程语言来解决我们的问题。由于我们需要支持各种加速器的高性能特性，而传统的编译器技术（如 LLVM 和 GCC）并不适合此类场景（任何基于它们的语言和工具也无法满足）。尽管它们支持各种 CPU 和一些常用的 GPU，但是这些编译器技术设计于几十年前，其无法全面支持现代芯片架构。现如今，专用机器学习加速器的标准技术则是 MLIR。

MLIR 是一个发起于 Google（目前已转移至 Modular）的相对较新的开源编译器基础设施，目前整个机器学习加速器社区中已广泛采用 MLIR。MLIR 优势在于它能够构建特定领域的编译器，特别是对于非传统 CPU 和 GPU 的特殊领域，例如：AI ASICS，量子计算系统，FPGA 和定制化芯片。

鉴于我们在 Modular 的目标是构建下一代 AI 平台，我们已经将 MLIR 应用于我们的一些基础设施，但我们没有一种编程语言可以完全释放 MLIR 在整个技术栈中的全部潜力。虽然许多其他项目现已使用 MLIR，但是 Mojo 是第一个专门为 MLIR 设计的重要编程语言，这使得 Mojo 足以胜任 AI 任务场景下编写系统级代码。

## 拥抱 Python 生态

我们对于 Mojo 的核心任务包括编译器内部的创新以及支持当前和新兴的加速器，同时考虑到语言语法或社区方面创新的非必要性。我们选择拥抱 Python 生态，这些归功于 Python 的广泛使用和 AI 生态对其的青睐，并且我们坚信 Python 是一种非常棒的语言。

Mojo 语言具有崇高的目标：我们期望 Mojo 与 Python 生态完全兼容，我们期望 Mojo 具备可预测的低层级性能和控制，我们需要 Mojo 具备部署代码子集至加速器的能力。除此之外，我们不打算创建一个碎片化的软件生态 — 我们不希望采用 Mojo 的 Python 用户再次经历 Python 2 迁移至 Python 3 的痛苦经历。这些目标相当宏伟却也相当有挑战性！

幸运的是，Mojo 应用虽然是一个全新的代码库，但我们并没有真正从概念开始设计。借鉴和参考 Python 从很大程度上简化了我们的设计工作，大多数语法已可以明确指定。因此，我们可以将精力集中在构建 Mojo 编译模型和系统编程这些特性上。与此同时，我们还受益于从其他编程语言（如：Rust、Swift、Julia、Zig、Nim 等）学到的大量经验教训，以及我们之前协助开发者迁移至新编译器和语言的经验，还包括我们从现有 MLIR 编译器生态系统获得的经验。

关于 Mojo 的正确长期目标，我们认为是成为 Python 超集（使得 Mojo 与现有 Python 程序兼容），并支持 CPython 实现以支持 Python 生态的长期发展。如果你是一个 Python 程序员，我们期待 Mojo 易于上手，同时 Mojo 也会提供新的工具集用于取代 C 和 C++，以满足安全且高性能的系统级代码开发场景。

我们并非要向整个世界证明“静态方式是最好的”亦或“动态方式是最好的”，恰恰相反，我们相信合适的才是最好的，所以我们设计了 Mojo，它赋予了伟大的程序员们自由使用静态或动态方式的权力。

### 我们为何选择 Python

Python 在 ML 和各类领域中处于主导地位。Python 易于学习且为重要的程序员群体所熟知，其拥有强大的开发社区和大量有价值的软件开发包，并且拥有各种各样优秀的工具集。Python 通过其动态编程能力支持优美且极富表现力的 API 开发，由此 TensorFlow 和 PyTorch 等机器学习框架将 Python 作为其 C++ 高性能运行时的前端。

对如今的 Modular 而言，Python 是我们 API 技术栈中不可或缺的一部分 — 这是由我们的用户所决定的。鉴于我们技术栈中的其他部分都是可以讨论和调整的，因此，我们应该遵循“Python 优先”这种方式。

从主观角度，我们相信 Python 是一种优美的编程语言。它具有简洁且可组合的抽象设计，避免了不必要的标点符号（与缩进类似，这些标点符号在实践中证明是多余的），它同时具备强大的（动态）元编程特性。所有这些 Python 特性都为我们提供了一种按照 Modular 所需进行语言扩展的便捷之径。我们由衷希望 Python 生态开发者能体会到我们的愿景：通过 Mojo 将 Python 提升到一个新的高度并达成相关目标 - 而非与 Python 是竞争关系。

## 兼容 Python

我们计划全面兼容 Python 生态，考虑到现有的两类兼容性，我们需要详细阐述全面兼容的含义：

在导入现有 Python 模块并在 Mojo 程序中使用它们的场景中，我们采用 CPython 进行互操作以使 Mojo 具备 100% 兼容性。

在将任何 Python 代码迁移至 Mojo 的场景而言，Mojo 还不具备完全兼容性。Mojo 已支持 Python 的许多核心功能，包括：async/await，错误处理，可变参数等。然而 Mojo 仍很年轻，其缺少 Python 的许多其他功能，甚至仍不支持类！

尽管还有很多工作要做，但是我们坚信一定能够实现这一目标，并且我们以团队的经验作为指导，通过他们自身的兼容性挑战之旅来构建其他主要技术：

关于 Clang 编译器（面向 C，C++，Objective-C，CUDA，OpenCL 等语言的编译器），它是 GCC，MSVC 和其他现有编译器的“兼容替代品”。Mojo 很难与之进行直接比较，但是 Clang 问题的复杂度要明显比实现 Python 兼容替代品的复杂度高一个数量级。

关于 Swift 编程语言，它拥抱了 Objective-C 运行时和相关语言生态，并逐步吸引了数百万的程序员（以及大量代码）。通过 Swift，我们获取了许多如何进行“运行时兼容”以及与原有运行时协作的经验与教训。

在进行 Python 和 Mojo 混合编程场景下，我们希望 Mojo 能够与 CPython 运行时直接交互，并且对 CPython 类和对象集成具有类似的支持(无需编译代码本身)。这提供了与现有代码的庞大生态系统的插件级兼容性，并且它支持渐进式迁移方法，增量迁移到 Mojo 会产生增量效益。

总之，我们相信通过专注于语言设计和与 Python 完全兼容的渐进式进展，一定会实现我们的目标。

需要说明的是，当您编写纯 Mojo 代码时，相关实现，编译或运行时并未使用任何 Python 技术。就 Mojo 本身而言，它是一种全新的编程语言，其具有全新的编译和运行时。

### 与 Python 的不同之处

TBD

## Python 的问题

TBD

### two-world 问题

TBD

### three-world 和 N-world 问题

TBD

### 移动端与服务端部署

TBD

## 相关工作

TBD

### 改进 CPython 和 JIT 编译时 Python

TBD

### Python 子集和其他类似 Python 的语言

TBD

### 与 C 兼容的 Python 超集

TBD

### Python 嵌入式 DSL

TBD
