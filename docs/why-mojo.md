# 为何是 Mojo🔥

当我们创立 Modular 时，我们本无意构建一种新的编程语言。但是当我们构建 [面向 ML/AI 基础设施的统一平台](https://www.modular.com/blog/the-case-for-a-next-generation-ai-developer-platform) 时，我们意识到整个技术栈的编程过于复杂。同时，我们手写了大量 MLIR，整个过程很费力。

我们需要的是一种创新且可扩展的编程模型，用于面向加速器（accelerators）和 AI 领域普遍存在的若干异构系统。这意味着编程语言需要具有强大的编译时元编程、集成自适应编译技术、缓存整个编译流程以及现有编程语言不支持的其他特性。

尽管加速器很重要，但最普遍且有时被忽视的“加速器”之一是主机 CPU。如今，CPU 拥有许多类似张量核（tensor-core-like）的加速器模块和其他 AI 加速单元，同时，它们也用于专用加速器无法处理的场景（例如：数据加载，预处理/后处理以及与外部系统的集成），因此，我们不能仅用一种仅适配特定处理器的“加速器语言”来提升 AI 性能。

面对 AI 应用场景需要解决所有这些问题，我们认为没有理由不能只用一种语言来完成。因此，Mojo 诞生了。

## 采用下一代编译器技术的语言

当我们意识到现有的编程语言无法解决 AI 计算的挑战时，我们开始重新思考如何设计和实现编程语言来解决我们的问题。由于我们需要支持各种加速器的高性能特性，而传统的编译器技术（如 LLVM 和 GCC）并不适合此类场景（任何基于它们的语言和工具也无法满足）。尽管它们支持各种 CPU 和一些常用的 GPU，但是这些编译器技术设计于几十年前，其无法全面支持现代芯片架构。现如今，专用机器学习加速器的标准技术则是 MLIR。

MLIR 是一个发起于 Google（目前已转移至 Modular）的相对较新的开源编译器基础设施，目前整个机器学习加速器社区中已广泛采用 MLIR。MLIR 优势在于它能够构建特定领域的编译器，特别是对于非传统 CPU 和 GPU 的特殊领域，例如：AI ASICS，量子计算系统，FPGA 和定制化芯片。

鉴于我们在 Modular 的目标是构建下一代 AI 平台，我们已经将 MLIR 应用于我们的一些基础设施，但我们没有一种编程语言可以完全释放 MLIR 在整个技术栈中的全部潜力。虽然许多其他项目现已使用 MLIR，但是 Mojo 是第一个专门为 MLIR 设计的重要编程语言，这使得 Mojo 足以胜任 AI 任务场景下编写系统级代码。

## 拥抱 Python 生态

我们对于 Mojo 的核心任务包括编译器内部的创新以及支持当前和新兴的加速器，同时考虑到语言语法或社区方面创新的非必要性。我们选择拥抱 Python 生态，这些归功于 Python 的广泛使用和 AI 生态对其的青睐，并且我们坚信 Python 是一种非常棒的语言。

Mojo 语言具有崇高的目标：我们期望 Mojo 与 Python 生态完全兼容，我们期望 Mojo 具备可预测的低层级性能和控制，我们需要 Mojo 具备部署代码子集至加速器的能力。除此之外，我们不打算创建一个碎片化的软件生态 — 我们不希望采用 Mojo 的 Python 用户再次经历 Python 2 迁移至 Python 3 的痛苦经历。这些目标相当宏伟却也相当有挑战性！

幸运的是，Mojo 应用虽然是一个全新的代码库，但我们并没有真正从概念开始设计。借鉴和参考 Python 从很大程度上简化了我们的设计工作，大多数语法已可以明确指定。因此，我们可以将精力集中在构建 Mojo 编译模型和系统编程这些特性上。与此同时，我们还受益于从其他编程语言（如：Rust、Swift、Julia、Zig、Nim 等）学到的大量经验教训，以及我们之前协助开发者迁移至新编译器和语言的经验，还包括我们从现有 MLIR 编译器生态系统获得的经验。

关于 Mojo 的正确长期目标，我们认为是成为 Python 超集（使得 Mojo 与现有 Python 程序兼容），并支持 CPython 实现以支持 Python 生态的长期发展。如果你是一个 Python 程序员，我们期待 Mojo 易于上手，同时 Mojo 也会提供新的工具集用于取代 C 和 C++，以满足安全且高性能的系统级代码开发场景。

我们并非要向整个世界证明“静态方式是最好的”亦或“动态方式是最好的”，恰恰相反，我们相信合适的才是最好的，所以我们设计了 Mojo，它赋予了伟大的程序员们自由使用静态或动态方式的权力。

### 我们为何选择 Python

TBD

## 兼容 Python

TBD

### 与 Python 的不同之处

TBD

## Python 的问题

TBD

### two-world 问题

TBD

### three-world 和 N-world 问题

TBD

### 移动端与服务端部署

TBD

## 相关工作

TBD

### 改进 CPython 和 JIT 编译时 Python

TBD

### Python 子集和其他类似 Python 的语言

TBD

### 与 C 兼容的 Python 超集

TBD

### Python 嵌入式 DSL

TBD
