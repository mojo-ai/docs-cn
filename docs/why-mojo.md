# 为何是 Mojo🔥

当我们创立 Modular 时，我们本无意构建一种新的编程语言。但是当我们构建 [面向 ML/AI 基础设施的统一平台](https://www.modular.com/blog/the-case-for-a-next-generation-ai-developer-platform) 时，我们意识到整个技术栈的编程过于复杂。同时，我们手写了大量 MLIR，整个过程很费力。

我们需要的是一种创新且可扩展的编程模型，用于面向加速器（accelerators）和 AI 领域普遍存在的若干异构系统。这意味着编程语言需要具有强大的编译时元编程、集成自适应编译技术、缓存整个编译流程以及现有编程语言不支持的其他特性。

尽管加速器很重要，但最普遍且有时被忽视的“加速器”之一是主机 CPU。如今，CPU 拥有许多类似张量核（tensor-core-like）的加速器模块和其他 AI 加速单元，同时，它们也用于专用加速器无法处理的场景（例如：数据加载，预处理/后处理以及与外部系统的集成），因此，我们不能仅用一种仅适配特定处理器的“加速器语言”来提升 AI 性能。

面对 AI 应用场景需要解决所有这些问题，我们认为没有理由不能只用一种语言来完成。因此，Mojo 诞生了。

## 采用下一代编译器技术的语言

当我们意识到现有的编程语言无法解决 AI 计算的挑战时，我们开始重新思考如何设计和实现编程语言来解决我们的问题。由于我们需要支持各种加速器的高性能特性，而传统的编译器技术（如 LLVM 和 GCC）并不适合此类场景（任何基于它们的语言和工具也无法满足）。尽管它们支持各种 CPU 和一些常用的 GPU，但是这些编译器技术设计于几十年前，其无法全面支持现代芯片架构。现如今，专用机器学习加速器的标准技术则是 MLIR。

MLIR 是一个发起于 Google（目前已转移至 Modular）的相对较新的开源编译器基础设施，目前整个机器学习加速器社区中已广泛采用 MLIR。MLIR 优势在于它能够构建特定领域的编译器，特别是对于非传统 CPU 和 GPU 的特殊领域，例如：AI ASICS，量子计算系统，FPGA 和定制化芯片。

鉴于我们在 Modular 的目标是构建下一代 AI 平台，我们已经将 MLIR 应用于我们的一些基础设施，但我们没有一种编程语言可以完全释放 MLIR 在整个技术栈中的全部潜力。虽然许多其他项目现已使用 MLIR，但是 Mojo 是第一个专门为 MLIR 设计的重要编程语言，这使得 Mojo 足以胜任 AI 任务场景下编写系统级代码。

## 拥抱 Python 生态

我们对于 Mojo 的核心任务包括编译器内部的创新以及支持当前和新兴的加速器，同时考虑到语言语法或社区方面创新的非必要性。我们选择拥抱 Python 生态，这些归功于 Python 的广泛使用和 AI 生态对其的青睐，并且我们坚信 Python 是一种非常棒的语言。

Mojo 语言具有崇高的目标：我们期望 Mojo 与 Python 生态完全兼容，我们期望 Mojo 具备可预测的低层级性能和控制，我们需要 Mojo 具备部署代码子集至加速器的能力。除此之外，我们不打算创建一个碎片化的软件生态 — 我们不希望采用 Mojo 的 Python 用户再次经历 Python 2 迁移至 Python 3 的痛苦经历。这些目标相当宏伟却也相当有挑战性！

幸运的是，Mojo 应用虽然是一个全新的代码库，但我们并没有真正从概念开始设计。借鉴和参考 Python 从很大程度上简化了我们的设计工作，大多数语法已可以明确指定。因此，我们可以将精力集中在构建 Mojo 编译模型和系统编程这些特性上。与此同时，我们还受益于从其他编程语言（如：Rust、Swift、Julia、Zig、Nim 等）学到的大量经验教训，以及我们之前协助开发者迁移至新编译器和语言的经验，还包括我们从现有 MLIR 编译器生态系统获得的经验。

关于 Mojo 的正确长期目标，我们认为是成为 Python 超集（使得 Mojo 与现有 Python 程序兼容），并支持 CPython 实现以支持 Python 生态的长期发展。如果你是一个 Python 程序员，我们期待 Mojo 易于上手，同时 Mojo 也会提供新的工具集用于取代 C 和 C++，以满足安全且高性能的系统级代码开发场景。

我们并非要向整个世界证明“静态方式是最好的”亦或“动态方式是最好的”，恰恰相反，我们相信合适的才是最好的，所以我们设计了 Mojo，它赋予了伟大的程序员们自由使用静态或动态方式的权力。

### 我们为何选择 Python

Python 在 ML 和各类领域中处于主导地位。Python 易于学习且为重要的程序员群体所熟知，其拥有强大的开发社区和大量有价值的软件开发包，并且拥有各种各样优秀的工具集。Python 通过其动态编程能力支持优美且极富表现力的 API 开发，由此 TensorFlow 和 PyTorch 等机器学习框架将 Python 作为其 C++ 高性能运行时的前端。

对如今的 Modular 而言，Python 是我们 API 技术栈中不可或缺的一部分 — 这是由我们的用户所决定的。鉴于我们技术栈中的其他部分都是可以讨论和调整的，因此，我们应该遵循“Python 优先”这种方式。

从主观角度，我们相信 Python 是一种优美的编程语言。它具有简洁且可组合的抽象设计，避免了不必要的标点符号（与缩进类似，这些标点符号在实践中证明是多余的），它同时具备强大的（动态）元编程特性。所有这些 Python 特性都为我们提供了一种按照 Modular 所需进行语言扩展的便捷之径。我们由衷希望 Python 生态开发者能体会到我们的愿景：通过 Mojo 将 Python 提升到一个新的高度并达成相关目标 - 而非与 Python 是竞争关系。

## 兼容 Python

我们计划全面兼容 Python 生态，考虑到现有的两类兼容性，我们需要详细阐述全面兼容的含义：

在导入现有 Python 模块并在 Mojo 程序中使用它们的场景中，我们采用 CPython 进行互操作以使 Mojo 具备 100% 兼容性。

在将任何 Python 代码迁移至 Mojo 的场景而言，Mojo 还不具备完全兼容性。Mojo 已支持 Python 的许多核心功能，包括：async/await，错误处理，可变参数等。然而 Mojo 仍很年轻，其缺少 Python 的许多其他功能，甚至仍不支持类！

尽管还有很多工作要做，但是我们坚信一定能够实现这一目标，并且我们以团队的经验作为指导，通过他们自身的兼容性挑战之旅来构建其他主要技术：

关于 Clang 编译器（面向 C，C++，Objective-C，CUDA，OpenCL 等语言的编译器），它是 GCC，MSVC 和其他现有编译器的“兼容替代品”。Mojo 很难与之进行直接比较，但是 Clang 问题的复杂度要明显比实现 Python 兼容替代品的复杂度高一个数量级。

关于 Swift 编程语言，它拥抱了 Objective-C 运行时和相关语言生态，并逐步吸引了数百万的程序员（以及大量代码）。通过 Swift，我们获取了许多如何进行“运行时兼容”以及与原有运行时协作的经验与教训。

在进行 Python 和 Mojo 混合编程场景下，我们希望 Mojo 能够与 CPython 运行时直接交互，并且对 CPython 类和对象集成具有类似的支持(无需编译代码本身)。这提供了与现有代码的庞大生态系统的插件级兼容性，并且它支持渐进式迁移方法，增量迁移到 Mojo 会产生增量效益。

总之，我们相信通过专注于语言设计和与 Python 完全兼容的渐进式进展，一定会实现我们的目标。

需要说明的是，当您编写纯 Mojo 代码时，相关实现，编译或运行时并未使用任何 Python 技术。就 Mojo 本身而言，它是一种全新的编程语言，其具有全新的编译和运行时。

### 与 Python 的不同之处

尽管 Mojo 成功的关键在于 Python 的兼容性和可迁移性，我们也同样希望 Mojo 成为第一梯队的编程语言（这意味着 Mojo 是一种独立的语言，而非依赖于另一种语言而存在）。我们不能为了保持兼容性而限制新关键字或语法特性的引入能力。因此，我们对兼容性采用了双重方式：

我们利用 CPython 来运行所有 Python 3 代码并不做任何修改，同时使用其运行时并确保无任何修改，以此保持与整个生态的完全兼容。尽管以这种方式运行代码并不会受益于 Mojo，但是这个生态的存在和可用性将会加速Mojo 演进，并强化 Python 在高级编程领域的优势。

我们将为那些从 Python 迁移到 Mojo 的开发者提供具备优秀兼容性的迁移工具。例如，为了避免因 Python 代码使用 Mojo 关键字相匹配的标识符而出现的迁移错误，Mojo 提供了反引号功能，其允许任何关键字可充当标识符。

总而言之，Mojo 具备优秀的可集成特性，可平滑集成至 CPython 生态中，同时也允许 Mojo 程序员采用渐进方式将 Python 代码（一次一个模块或文件）迁移至 Mojo。这也是 Apple 迁移 Objective-C 至 Swift 所采用的行之有效的方法。

目前 Mojo 其余部分的设计以及对迁移特性的支持还需要一段时间去完成，我们仍坚信这种策略会使我们聚焦而避免分散。我们同时认为与 CPython 的关系可以在两个方向进行建设 - 如果 CPython 团队最终使用 Mojo 而非 C 来重写解释器，那绝对是酷毙了！🔥

## Python 的问题

以 Mojo 成为 Python 超集为目标，我们相信可以解决许多 Python 已知问题。

Python 有一些众所周知的问题 - 最明显的是低层级的性能问题和 CPython 实现细节问题，例如：导致 Python 成为单线程的全局解释器锁（GIL）。虽然有许多进行中的项目正在努力挑战和解决这些问题，但是 Python 在 AI 领域引发的这些问题尤甚。我们将在 2023 年讨论这些技术的波及程度而非技术局限性。

注意：我们在本节提及的 Python 均为 CPython 实现。我们稍后将会讨论其他 Python 实现。

### two-world 问题

由于各种原因，Python 并不适合系统编程。不过幸运的是，Python 作为胶水层语言具有惊人的优势，支持绑定 C 和 C++ 低级语言，支持加载 C、C++ 和许多其他具有更好性能的语言库。这就是 NumPy，TensorFlow，PyTorch 和生态系统中其他大量库实现成为可能的重要原因。

不幸的是，虽然这种方法是构建高性能 Python 库的有效方法，但它也是有代价的：构建这类语言混合库非常复杂。它需要对 CPython 的内部相当了解，需要 C/C++（或其他语言）编程知识（破坏了使用 Python 的初衷），从而导致发展大型框架变得较为困难，并且（ML 场景）将世界推向“基于图”的编程模型，相比“渴望模式”系统，其基本可用性要差一些。TensorFlow 和 PyTorch 在这方面确实面临着重大挑战。

除了 two-world 问题引发系统复杂性，它还使生态系统中的其他一切都变得日益复杂。调试器通常不能跨越 Python 和 C 代码调试，而那些可以跨越 Python 和 C 的代码却不被广泛接受。令人痛苦的是，Python 包还需处理除 Python 之外的 C/C++ 代码。像 PyTorch 这样的项目，其已投入大量 C++，为了充分利用 Python 可用性，PyTorch 有意尝试将更多的代码库迁移到 Python。

### three-world 和 N-world 问题

在 Python 生态中普遍存在 two-world 问题，而对 ML 框架的开发者来说，这种情况则更糟。AI 发展正在提速，相关加速器使用定制化的编程语言，例如：CUDA。尽管 CUDA 与 C++ 有关联，但是它自身也存在特殊问题和局限性，它缺少调试器或分析器等一致性工具。因此它只能与单个硬件制造商强相关。

AI 在硬件发展前沿拥有令人难以置信的创新，由此也导致其复杂性正在失去控制。现如今有多次为加速器（OpenCL，Sycl，OneAPI 等）构建有限编程系统的尝试。这种复杂性正持续爆炸式增长，同时，这些系统并没有解决工具和生态中严重伤害行业的根本性碎片化问题 — 与此相反，它们正在增加碎片化。

### 移动端与服务端部署

Python 生态面临的另一个挑战是部署。关于部署有很多方面，包括：如何控制依赖，如何部署二进制目标文件“a.out”，以及如何改善多线程及其性能。我们希望 Python 生态能在这些领域取得重要的进展。

## 相关工作

我们知道还有许多在改进 Python 方面的努力，但是它们并没有解决那些基础性的问题，而我们旨在通过 Mojo 解决这些问题。

目前进行中的 Python 改进工作包括：加速 Python 和取代 GIL，构建类似 Python 但实际作为 Python 子集的语言，以及构建与 Python 可集成但不是第一级别语言的嵌入式领域特定语言（DSL）。虽然我们无法提供所有改进工作的详尽清单，但是我们可以谈论一下这些项目所面临的若干挑战，以及它们无法解决 Mojo 所处理问题的原因。

### 改进 CPython 和 JIT 编译时 Python

最近，Python 社区已花费了大量精力来提升 CPython 性能和其他实现问题，并且已显示出巨大的进展。这项工作非常出色，它逐步改进了当前 CPython 的实现。例如：相比 Python 3.10，Python 3.11 通过内部改进将性能提升了 10%-60%，Python 3.12 期待通过实现跟踪优化器可以有更大突破。许多其他项目都在试图征服 GIL，；类似 PyPy 这类项目（以及其他许多项目）已经使用 JIT 编译和跟踪方法来加速 Python。

虽然我们是这些伟大努力的粉丝，并且觉得它们对社区确实具有价值和令人兴奋，但不幸的是，它们无法满足我们在 Modular 中的需求，因为它们无法在加速器上提供统一的语言。如今，许多加速器支持的动态功能非常有限，甚至性能很差。此外，系统程序员不仅仅追求“性能”，而且他们通常还希望对计算方式进行大量的可预测性及可控制。

我们希望消除在 Python 库中使用 C 或 C++ 的需求，我们寻求尽可能高的性能，并且在某些情况下我们根本无法接受动态功能。因此，以上这些方法对我们都无济于事。

### Python 子集和其他类似 Python 的语言

目前有很多构建一个“可部署的” Python 的尝试，例如：来自 PyTorch 项目的 TorchScript。这些都非常有用，它们通常提供依赖度较低的部署方案，并且具有一定的高性能。因为它们使用类似 Python 语法，所以它们比新语言更易于学习。

另一方面，这些语言还没有被广泛采用 — 由于它们是 Python 的一个子集，它们通常不与 Python 生态进行互操作，缺少出色的工具（如调试器），并且经常单方面改变了 Python 中不方便的语法特性，这些破坏了 Python 兼容性并进一步分裂了整个生态。例如：许多更改简单整数类型的封装处理，而不是生成与 Python 相兼容的数学语义。

这些方法的挑战在于它们试图解决 Python 的一个弱点，然而它们并不擅长 Python 的强项。这些充其量可以提供 C 和 C++ 的新替代方案，但是若不解决 Python 动态用例，它们就无法解决“two-world 问题”。这种方法会导致碎片化和兼容性缺失，使得迁移过程变得困难甚至不可能 - 我们回想一下从 Python 2 迁移到 Python 3 的过程是多么具有挑战性。

### 与 C 兼容的 Python 超集

由于 Mojo 被设计为具有改进的系统编程特性的 Python 超集，因此它与其他 Python 超集（如：Pyrex 和 Cython）具有类似的高级思想。与 Mojo 一样，这些项目定义了自己的语言，它们也支持 Python 语言。它们允许您为 Python 编写性能更高的扩展插件，以便与 Python 和 C 库互操作。

这些 Python 超集非常适合某些类型的应用程序，它们已被一些流行的 Python 库所应用，并且取得非常好的效果。然而，他们无法解决 Python 的 two-world 问题，原因在于他们依赖 CPython 作为他们的核心语义，所以没有它就无法运作，与之相比，Mojo 只在必要时使用 CPython 以提供与现有 Python 代码的兼容性。Mojo 纯代码不使用任何已有的运行时或编译器技术，而是使用基于 MLIR 基础架构在各种硬件上实现高性能执行。

### Python 嵌入式 DSL

另一种常见的方法是在 Python 中构建嵌入式领域特定语言（DSL），其通常与 Python 装饰器一同安装。目前有许多类似的例子（TensorFlow @tf.function 装饰器，OpenAI Triton 编程模型中的 @triton.jit 等）。这些系统的主要好处之一保持了与 Python 工具生态的兼容性，同时可以本地集成至 Python 上下文逻辑中，也允许嵌入式迷你语言，该类语言与 Python 优势保持共存，可以用于动态用例。

不幸的是，这些系统提供的嵌入式迷你语言通常具有令人惊讶的局限性，无法与调试器和其他工作流工具进行很好地集成，并且不支持我们寻求的统一异构计算语言的本地化语言集成，而这是编写大规模内核和系统的主要方式。

通过 Mojo，我们希望通过简洁化和一致性增强来推动整个系统的可用性。嵌入式 DSL 是启动和运行演示的便捷方式，但是我们愿意付出额外的努力，为我们的用例提供更好的可用性和可预测性。

若查看目前我们使用 Mojo 构建的所有特性，请参阅 [Mojo 编程手册](https://docs.modular.com/mojo/programming-manual.html)。
